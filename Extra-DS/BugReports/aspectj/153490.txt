IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??
I try out Contract4J 0.5 with AspectJ 1.5.2 (Build 20060629124300) and Eclipse 3.2 (Build M20060629-1905) under Windows XP SP2 and Java 1.5.0_06. So I became following exception. (You will find my testcode below the exception.) I am not sure if this bug related to Contract4J or to AspectJ!? ==== The Exception ==== java.lang.IllegalStateException at org.aspectj.weaver.asm.AsmDelegate.getFormalTypeParametersFromOuterClass(AsmDelegate.java:465) at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:395) at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538) at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426) at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64) at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155) at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134) at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:618) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:928) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:449) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:903) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:326) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:829) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:422) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:271) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType?? ==== My TestCode ==== import org.contract4j5.Contract; import org.contract4j5.Post; import org.contract4j5.Pre; import org.contract4j5.aspects.Contract4J; // this is a dummy code!! @Contract public class Foo { private String fooField = null; @Pre("nr != null") public void setFooField(String f) { fooField = f; } @Post("$return != null") public String getFooField() { return fooField; } public static void main(String[] args) { Contract4J.setEnabled(Contract4J.TestType.Pre, true); //1 Contract4J.setEnabled(Contract4J.TestType.Post, true); //2 Contract4J.setEnabled(Contract4J.TestType.Invar, true); //3 Foo foo = new Foo(); foo.setFooField(null); System.out.println(foo.getFooField()); } }