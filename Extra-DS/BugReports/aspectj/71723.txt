Inconsistency in scoping of protected members in ITDs
When introducing new member functions to existing classes via inter-type declarations, the scoping rules that apply to the ITD bodies are the same as for the aspect - for example, private members of the target class cannot be accessed unless the aspect is privileged. Similarly, protected members of classes in different packages should not be visible in ITDs unless the aspect is privileged. This rule is only enforced for protected members declared in the target class - protected members that are inherited are visible from ITDs in aspects in different packages. The following is an example of this: ---------------------- package foo; public class Foo extends AncientFoo { protected int i() { return 42; } public static void main(String[] args) { new Foo().doStuff(); } public void doStuff() { } protected int ancientI() { return 42; } } class AncientFoo { protected int ancientI() { return -42; } protected int ancientJ() { return 0; } } ---------- package bar; import foo.Foo; aspect Bar { public void Foo.doing() { try { System.out.println(i()); // fails in ajc System.out.println(ancientI()); // fails in ajc System.out.println(ancientJ()); // succeeds System.out.println(clone()); // succeeds } catch(Throwable t) { } } before(Foo f) : call(* doStuff(..)) && target(f) { f.doing(); } } ------------------- All four calls in Foo.doing() should fail, as they refer to protected members of foo.Foo from package bar. However, only the first 2 - the ones directly declared/overridden in foo.Foo - are detected as errors, and removing them makes the rest compile and execute. Best wishes, Pavel