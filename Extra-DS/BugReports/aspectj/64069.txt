ITD name clashes with private members
When weaving into source, ITDs for constructors and methods override private members of the same signature: it is as if the private member never existed. This is illustrated by the example in Dups.java. The same example, when the classes are compiled separately and using bytecode weaving, gives a ClassFormatError upon execution. The situation for fields is different: the compiler flags an error when an ITD tries to introduce a public x where a private x already existed. The error is however flagged only when x is used in the class. Without any uses, such a clashing field is passed by the compiler, but when the program is run, java throws a ClassFormatError. This behaviour is illustrated in DupField.java The above seems to be a bug: the behaviour should be consistent in all situations. Request: make it always legal to introduce a new member by ITD that has the same name/signature as a private member. Mangle the private member and all its uses. /* --------------------------------------------------------------- Dups.java When weaving into source, ITDs for constructors and methods override private members of the same name. Using bytecode weaving (and separate class files for each of the classes) this example gives a ClassFormatError upon execution. */ aspect Aspect { public A.new() { super(); System.out.println("ITD A()"); } public void A.bar() { System.out.println("ITD bar"); } } class A { void foo() { A a = new A(); bar(); } private A() { super(); System.out.println("private A()"); } private void bar() { System.out.println("private bar"); } } public class Dups { static public void main(String[] args) { new A().foo(); } } /* ------------------------------------------------------------------ DupField.java The compiler flags an error when an ITD tries to introduce a public x where a private x already existed. The error is however flagged only when x is used in the class. Without any uses, such a clashing field is passed by the compiler, but when the program is run, java throws a ClassFormatError. This behaviour is illustrated in DupField.java: to see the ClassFormatError, comment out the assignment "x=0" in foo(). */ aspect Aspect { public int A.x; } class A { private int x; void foo() { // when the line below is commented, we get a runtime error x=0; // error: The field x is ambiguous } } public class DupField { static public void main(String[] args) { new A(); } }