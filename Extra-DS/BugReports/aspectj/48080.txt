Context information in declare warning/error messages
*** to be discussed on aspectj-dev / users before implementing *** We have found it useful to be able to include contextual information in the messages produced by declare warning /error. We want to be able to write something like: declare warning: call(* com.ibm.ws..*(..)) : "Call to protected WAS API: %s"; and get the compiler message: "Call to protected WAS API: void com.ibm.ws.SomeClass.someMethod(boolean)" We prototyped a solution using substitution variables as follows: %% inserts a % character %k inserts the joinpoint kind %s inserts the signature at the joinpoint %t inserts the name of the declaring type at the joinpoint %i inserts the name of the identifier at the joinpoint %j inserts a string representation of the joinpoint %f inserts the filename where the match was found %l inserts the line number where the match was found %a inserts the file and line number of the declare error/warning definition (this may not be the perfect set...) Here's a complete mini-example showing all the subsitutions in action : Hello.java ========= public class Hello { public static void main(String[] args) { System.out.println("Hello"); new Hello().sayItToo(); } private void sayItToo() { System.out.println("me too"); } } Warn.java ========= public aspect Warn { declare warning : execution(* Hello.*(..)) : "My warning:\n%%k=%k\n%%s=%s\n%%t=%t\n%%i=%i\n%%j=%j\n%%f=%f\n%%l=% l\n%%a=%a"; declare warning : call(* Hello.*(..)) : "Illegal call to %t.%i(..)"; } To get the following output: C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:4 Illegal call to Hello.sayItToo(..) C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:3 My warning: %k=method-execution %s=void Hello.main(java.lang.String[]) %t=Hello %i=main %j=method-execution(void Hello.main(java.lang.String[])) %f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java %l=3 %a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3 C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:8 My warning: %k=method-execution %s=void Hello.sayItToo() %t=Hello %i=sayItToo %j=method-execution(void Hello.sayItToo()) %f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java %l=8 %a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3 3 warnings The following patch implements the extension (warning - based on a version of Checker.java from a while back). Index: Checker.java =================================================================== RCS file: /home/technology/org. aspectj/modules/weaver/src/org/aspectj/weaver/Checker.java,v retrieving revision 1.5 diff -u -r1.5 Checker.java --- Checker.java 12 Mar 2003 19:51:43 -0000 1.5 +++ Checker.java 19 Jul 2003 12:34:12 -0000 @@ -17,6 +17,7 @@ import java.util.Collections; import org.aspectj.bridge.IMessage; +import org.aspectj.bridge.ISourceLocation; import org.aspectj.bridge.Message; import org.aspectj.weaver.patterns.DeclareErrorOrWarning; import org.aspectj.weaver.patterns.PerClause; @@ -49,7 +50,7 @@ public boolean match(Shadow shadow, World world) { if (super.match(shadow, world)) { world.getMessageHandler().handleMessage( - new Message(msg, + new Message(format(msg,shadow), isError ? IMessage.ERROR : IMessage.WARNING, null, shadow.getSourceLocation())); @@ -63,5 +64,85 @@ } public Collection getThrownExceptions() { return Collections.EMPTY_LIST; } + +// %% inserts a % character +// %k inserts the joinpoint kind +// %s inserts the signature at the joinpoint +// %t inserts the name of the declaring type at the joinpoint +// %i inserts the name of the identifier at the joinpoint +// %j inserts a string representation of the joinpoint +// %J inserts an extended string representation of the joinpoint +// %f inserts the filename where the match was found +// %l inserts the line number where the match was found +// %a inserts the name of the aspect where the declare was defined + private String format(String msg, Shadow shadow) { + StringBuffer ret = new StringBuffer(); + for(int i = 0; i < msg.length(); i++) { + if (msg.charAt(i) != '%') { + ret.append(msg.charAt(i)); + } else { + // its a substitution character + int subCharPos = i+1; + if (subCharPos < msg.length()) { + i++; // consume it + substitute(ret,shadow,msg.charAt(i)); + } + } + } + return ret.toString(); + } + + /** + * @param buf the buffer in which to insert the substitution + * @param shadow shadow from which to draw context info + * @param c the substitution character + */ + private void substitute(StringBuffer ret, Shadow shadow, char c) { + ISourceLocation loc; + switch(c) { + case '%': + ret.append('%'); + break; + case 'k': // kind + ret.append(shadow.getKind().getName()); + break; + case 's': + ret.append(shadow.getSignature()); + break; + case 't': + ret.append(shadow.getEnclosingType()); + break; + case 'i': + ret.append(shadow.getSignature().getName()); + break; + case 'j': + case 'J': + ret.append(shadow.toString()); + break; + case 'f': // file name + loc = shadow.getSourceLocation(); + if ((loc != null) && (loc.getSourceFile() != null)) { + ret.append(loc.getSourceFile().toString()); + } + break; + case 'l': // line number + loc = shadow.getSourceLocation(); + if (loc != null) { + ret.append(loc.getLine()); + } + break; + case 'a': // aspect file and line number + loc = getSourceLocation(); + if ((loc != null) && (loc.getSourceFile() != null)) { + ret.append(loc.getSourceFile().toString()); + ret.append(':'); + ret.append(loc.getLine()); + } + break; + default: // unknown substitution character, leave alone + ret.append('%'); + ret.append(c); + } + } }